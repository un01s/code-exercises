# Data Structure and Algorithm in C++

Go over basic data structures and algorithms. At the same time pick up the missing parts of C++, and other languages. GPU? Networking? ML?

The order of learning is to follow basic data structures and common algorithms based on them, and to implement the solutions of LeetCode questions in C++ and other languages.

| chapter | content |
| ------- | ------- |
| 01-hello | [hello](https://github.com/un01s/code-exercises/tree/main/01-hello) |
| 02-array | [array](https://github.com/un01s/code-exercises/tree/main/02-array) |
| 03-linked list | [linked-list](https://github.com/un01s/code-exercises/tree/main/03-linkedlist) |
| 04-hash table | [hash table](https://github.com/un01s/code-exercises/tree/main/04-hashtable) |
| 05-string | [string](https://github.com/un01s/code-exercises/tree/main/05-string) |
| 06-double-pointer | [double-pointer](https://github.com/un01s/code-exercises/tree/main/06-doubleptr) |
| 07-stack and queue | [stack and queue](https://github.com/un01s/code-exercises/tree/main/07-stackqueue) |
| 08-binary tree | [binary tree](https://github.com/un01s/code-exercises/tree/main/08-binarytree) |
| 09-back tracking | [back tracking](https://github.com/un01s/code-exercises/tree/main/09-backtracking) |
| 10-greedy algorithm | [greedy](https://github.com/un01s/code-exercises/tree/main/10-greedy) |
| 11-dynamic programming | [DP](https://github.com/un01s/code-exercises/tree/main/11-dp) | 
| 12-monotonic stack | [monotonic stack](https://github.com/un01s/code-exercises/tree/main/12-monotonicStack) |
| 13-graph | [graph](https://github.com/un01s/code-exercises/tree/main/13-graph) |

## notes on data structures and algorithms

Array, stack, heap/queue, priority queue, deque and so on are linear structures with special and limited access to their elements. The linked list is logically linear and physically non-linear. Then binary trees and graphs become even more nonlinear. Both array and linked list are basics.
 
Then hashing, two-pointer, sliding window, binary search are clever with specific conditions to apply. DFS, BFS, backtracking, DP, greedy are just general ideas to deal with specific problems, somwhere they are very close to brute force that is the strength of computers. 

The idea of recursion in algorithms is very powerful. Together with iteration, both are different traversal approaches. For recursion, go from head to tail or reversely. This is also a string point of computer.

Other topics like tries, knapsack, intervals, bit-manipulation, math and geomotry are more specific.

## references

* [1 leetcode-master](https://github.com/youngyangyang04/leetcode-master)

* [2 leetcode analysis](https://github.com/wisdompeak/LeetCode)

* [3 fucking algorithm](https://github.com/labuladong/fucking-algorithm)

* [4 leetcode solution](https://github.com/doocs/leetcode)

* [awesome leetcode algo](https://github.com/hicodebear/awesome-leetcode-algorithm)

* [leetcode neetcode](https://github.com/neetcode-gh/leetcode)

* [leetcode solutions](https://github.com/purvasingh96/My-Leetcode-Solutions)

* [leetcode records](https://github.com/kk140906/leetcode_records)

* [competitive programming](https://github.com/cp-algorithms/cp-algorithms)

## notes

* [leetcode algo](https://github.com/doocs/leetcode)

* [c++ primer](https://github.com/pezy/CppPrimer)

* some c++ book list

  * [design patterns](https://github.com/pezy/DesignPatterns)

  * [cpp books](https://github.com/saeed771/cpp_book)

  * [awesone modern cpp](https://github.com/rigtorp/awesome-modern-cpp)

  * https://github.com/yuchdev/CppBooks

  * https://gist.github.com/tassoevan/0f7edd03e19f9674df07

* [algorithm](https://github.com/labuladong/fucking-algorithm)

* [leetcode practices](https://github.com/keineahnung2345/leetcode-cpp-practices)

* [leetcode wang](https://github.com/wind-liang/leetcode)

* [leetcode training](https://github.com/GardianT/leetcode-training)

* [leetcode](https://github.com/yunyanliluo/leetcode)

* [leetcode](https://github.com/hezhaojiang/leetcode-cpp/)

